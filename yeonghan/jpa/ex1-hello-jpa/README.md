### 간단한 정리

엔티티 매니저 팩토리
- 어플리케이션 전체 공유
  엔티티 매니저
- 쓰레드 간 공유가 되지 않음.
- 쓰레드 하나 당 점유
  데이터 변경
- 한 트랜잭션 안에서
    - Why?
    - 쓰레드 하나가 EM을 점유하기 때문
    - 데이터 변경을 두 트랜잭션에 거쳤을 때, 발생하는 문제점
      - 데이터 무결성을 침해 

영속성 컨텍스트
- 엔티티를 저장하는 영구적인 환경
- 논리적인 개념
  비영속/영속/준영속/삭제
- 비영속: 객체 레벨
- 영속: 객체와 DB 사이 레벨
    - ID: 객체로 1차 캐싱
    - find 연산 시 1차 캐시에서 선 조회
    - 1차 캐시에 없을 경우 DB 조회 후 1차 캐시에 저장
    - 쓰기지연
        - 트랜잭션 간 1차 캐시에 객체 저장 후 한 번에 query 발행
        - commit 시점에 query를 발행하는 구조
            - 1차 캐시에 데이터가 있으면, 따로 저장을 하지 않아도 commit에서 알아서 식별
            - ID: 객체 | 스냅샷 과 같은 형태로 있음.
    - Flush
      - 스냅샷과 객체를 비교 후 변경사항이 있을 경우, flush (Dirty Checking)
      - 한 트랜잭션 내 JPQL 쿼리 실행 시 Flush가 자동으로 호출 됨
      - JPQL은 DB 레벨에 직접 접근, DB에 데이터가 있어야 하므로 1차 캐시 내용이 미리 Flush 됨
      - FlushModeType으로 관리 가능
- 준영속: 영속 -> 영속성 컨텍스트에서 분리됨 (Detached)

Column Unique vs Table Unique
- Column Unique는 이름 설정이 랜덤
- Table Unique를 활용하는 것이 에러 식별 가능성에 좋음

@Temporal
- Legacy에서 Date 필드를 쓸 경우만

@Id
- Identity
  - DB에게 ID 전략을 맡김
  - MySQL Auto Increment의 단점 
    - 트랜잭션 내에서 1회 Insert가 필요
- squence
  - oracle, postgre와 같은 DB의 ID 전략
  - 마찬가지로 트랜잭션 내 1회 select가 필요
    - 성능을 최적화 하기 위해 AllocationSize를 활용가능
- Table
  - 비추, DB 낭비 + 성능 감소
  - squenece와 유사

---

객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.
테이블
- 외래 키로 조인
- 연관 관계 1개
객체
- 참조
- 연관 관계 2개
연관 관계의 주인
- 연관되어 있는 두 객체 중 어느 것에 외래키를 둘 것 인지?
- 왜 필요한 개념?
  - 연관되어 있는 두 객체 중 명확히 외래키를 관리하는 책임이 필요
  - 안그럼, Member와 Team 모두 다 외래키를 관리하게 됨
  - 둘 중 누가 주인 ?
    - 1:N 에서 N 포지션이 연관관계의 주인
    - 핵심1. 주인은 mappedBy가 사용되지 않음
    - 핵심2. 주인이 아닌데 컬렉션 레벨에서 수정하면, 현재 관리중인 객체가 아닌 다른 객체의 DB Query가 작성됨
  - 주인 != 객체 비즈니스 핵심 포인트
    - 주인이라고 관련 비즈니스 로직을 주인에서 처리하는 것은 아니다.

---

단방향 vs 양방향 연관관계
- 되도록이면 양방향은 사용하지 않는 것이 좋다.
- 사용한다면, 조회 용으로
- 책임의 관심사를 명확히 분리할 줄 알아야 함.

일대일 연관관계는 어떻게?
- 누가 주인이 될 지 정하는게 관건
- 양방향 관계를 사용해도 별 상관은 없음.
  - 다만, 일대일에서는 지연로딩이 안됨.
  - 굳이 지연로딩을 할 필요가 없어서 즉시 로딩이 됨.
  - 의미 없는 추가 쿼리가 발생할 수 있음.
- 보통 DBA와 협의 후 결정

다대다 연관관계를 사용하면 안되는 이유
- 객체 레벨에서는 표현이 됨.
- 엔티티 레벨에서는 표현이 안됨.
- 1:N + N:1로 표현
  - 중간 테이블의 역할이 있을 수 있음.
  - 해당 책임에 집중할 수 있음.
- 중간 테이블의 ID는 어떻게 ?
  - FK의 복합키 vs PK
  - 의미 없는 PK가 존재할 수 있음.
  - 복합키 제약, 참조 등이 너무 복잡해짐
  - TradeOff가 분명, 하지만 PK를 통해 생산성 높이는게 더 좋다고 판단

---

상속관계 전략
1. @Inheritance join 
- Dtype을 지정해서 어떤 구현체에 대한 정보인지 식별하기 용이하도록
  - DiscriminatorColumn
  - Dtype 구현체 이름 지정: DiscriminatorValue
- 장점
  - 상속관계를 정규화된 join table로 표현
  - 정석
- 단점
  - join 복잡도
  - insert * 2

2. @Inheritance singleTable
- Dtype이 필수, 마찬가지로 DiscriminatorColumn으로 표현
  - 없어도 됨, 필드 명시할 때 사용
- 장점
  - 성능
- 단점
  - 필요없는 null 필드
  - 테이블이 커지면, 조회 성능이 낮아질 수 있음.

3. @Inheritance tablePerClass
- Dtype이 없음.


---
Proxy 매커니즘
1. Entity 객체에 접근 -> 실제로 프록시 객체에 접근
2. 프록시 객체에 정보가 있다면 ? 그대로 정보를 반환
3. 프록시 객체에 정보가 없다면 ? 영속성 컨텍스트에 엔티티 초기화 요청
4. 영속성 컨텍스트는 DB로 부터 조회
5. Proxy -> 조회한 Entity 를 가르킴

Proxy 확인
1. 프록시 인스턴스 여부 확인
  `emf.getPersistenceUnitUtil().isLoaded(Entity.class)`
2. 프록시 클래스 이름 확인
  `entity.getClass().getName()`

